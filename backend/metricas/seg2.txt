// VALIDA√á√ÉO COMPLETA DA M√âTRICA DE SEGURAN√áA 2
console.log('%cüîê VALIDA√á√ÉO - M√©trica de Seguran√ßa 2', 'color: #3498db; font-size: 18px; font-weight: bold;');
console.log('%cTaxa de dados criptografados', 'color: #3498db; font-size: 14px;');
console.log('%cF√≥rmula: x = DC √∑ DT √ó 100', 'color: #2c3e50; font-size: 14px;');
console.log('===============================================');

// Fun√ß√£o principal de valida√ß√£o
const validateSecurityMetric2 = async () => {
  console.log('\nüìã CHECKLIST DE VALIDA√á√ÉO:');
  
  let metricsData = null;
  
  // 1. Tentar buscar m√©tricas da API
  try {
    console.log('üîç 1. Buscando m√©tricas da API...');
    const response = await fetch('http://localhost:3000/api/encryption/metrics');
    
    if (response.ok) {
      metricsData = await response.json();
      console.log('‚úÖ M√©tricas obtidas da API com sucesso');
    } else {
      throw new Error(`API retornou status ${response.status}`);
    }
  } catch (error) {
    console.log('‚ùå N√£o foi poss√≠vel acessar a API:', error.message);
    console.log('üí° Criando dados de teste para valida√ß√£o...');
    
    // Dados de teste
    metricsData = {
      success: true,
      metric: 'Taxa de dados criptografados',
      formula: 'x = DC √∑ DT √ó 100',
      values: {
        DC: 45,    // Dados Criptografados
        DT: 60,    // Total de Dados Sens√≠veis
        x: 75      // Taxa
      },
      calculation: 'x = 45 √∑ 60 √ó 100 = 75%',
      interpretation: 'Bom - Maioria dos dados sens√≠veis est√° protegida',
      status: 'GOOD',
      recommendations: [
        'Implementar criptografia para campos restantes',
        'Revisar controllers que n√£o est√£o aplicando criptografia'
      ]
    };
  }

  // 2. Extrair valores
  const DC = metricsData.values.DC;
  const DT = metricsData.values.DT;
  const x = metricsData.values.x;

  console.log('\nüìä DADOS OBTIDOS:');
  console.log(`   DC (Dados Criptografados): ${DC}`);
  console.log(`   DT (Total de Dados Sens√≠veis): ${DT}`);
  console.log(`   x (Taxa de Criptografia): ${x}%`);

  // 3. Validar a f√≥rmula
  console.log('\nüßÆ VALIDA√á√ÉO DA F√ìRMULA:');
  const calculatedX = DT > 0 ? (DC / DT) * 100 : 0;
  const formulaIsCorrect = Math.abs(calculatedX - x) < 0.01;
  
  console.log(`   F√≥rmula: x = ${DC} √∑ ${DT} √ó 100`);
  console.log(`   Calculado: ${calculatedX.toFixed(2)}%`);
  console.log(`   Registrado: ${x}%`);
  console.log(`   ‚úÖ F√≥rmula correta: ${formulaIsCorrect ? 'SIM' : 'N√ÉO'}`);

  // 4. Validar range (0% a 100%)
  console.log('\nüìà VALIDA√á√ÉO DO RANGE:');
  const isInRange = x >= 0 && x <= 100;
  console.log(`   0 ‚â§ ${x}% ‚â§ 100: ${isInRange ? '‚úÖ DENTRO' : '‚ùå FORA'}`);

  // 5. Validar consist√™ncia dos dados
  console.log('\nüîç VALIDA√á√ÉO DE CONSIST√äNCIA:');
  const hasValidData = DC >= 0 && DT >= 0 && DC <= DT;
  console.log(`   DC ‚â• 0: ${DC >= 0}`);
  console.log(`   DT ‚â• 0: ${DT >= 0}`); 
  console.log(`   DC ‚â§ DT: ${DC <= DT}`);
  console.log(`   ‚úÖ Dados consistentes: ${hasValidData ? 'SIM' : 'N√ÉO'}`);

  // 6. Validar interpreta√ß√£o
  console.log('\nüìñ VALIDA√á√ÉO DA INTERPRETA√á√ÉO:');
  let interpretationIsCorrect = false;
  if (x >= 95 && metricsData.interpretation.includes('Excelente')) interpretationIsCorrect = true;
  else if (x >= 80 && x < 95 && metricsData.interpretation.includes('Bom')) interpretationIsCorrect = true;
  else if (x >= 60 && x < 80 && metricsData.interpretation.includes('Regular')) interpretationIsCorrect = true;
  else if (x < 60 && metricsData.interpretation.includes('Cr√≠tico')) interpretationIsCorrect = true;
  
  console.log(`   Interpreta√ß√£o: "${metricsData.interpretation}"`);
  console.log(`   ‚úÖ Interpreta√ß√£o correta: ${interpretationIsCorrect ? 'SIM' : 'N√ÉO'}`);

  // 7. Calcular pontua√ß√£o
  console.log('\nüéØ PONTUA√á√ÉO FINAL:');
  let score = 0;
  if (formulaIsCorrect) score += 30;
  if (isInRange) score += 20;
  if (hasValidData) score += 20;
  if (interpretationIsCorrect) score += 20;
  if (metricsData.recommendations && metricsData.recommendations.length > 0) score += 10;

  console.log(`   F√≥rmula correta: ${formulaIsCorrect ? '+30' : '+0'}`);
  console.log(`   Range v√°lido: ${isInRange ? '+20' : '+0'}`);
  console.log(`   Dados consistentes: ${hasValidData ? '+20' : '+0'}`);
  console.log(`   Interpreta√ß√£o correta: ${interpretationIsCorrect ? '+20' : '+0'}`);
  console.log(`   Recomenda√ß√µes presentes: ${metricsData.recommendations ? '+10' : '+0'}`);
  console.log(`   üìä PONTUA√á√ÉO TOTAL: ${score}/100`);

  // 8. Resultado final
  console.log('\nüéä RESULTADO FINAL:');
  if (score >= 80) {
    console.log('%c‚úÖ M√âTRICA 2 VALIDADA COM SUCESSO!', 'color: green; font-size: 16px; font-weight: bold;');
    console.log('%cA M√©trica de Seguran√ßa 2 est√° funcionando corretamente.', 'color: green;');
  } else if (score >= 60) {
    console.log('%c‚ö†Ô∏è M√âTRICA 2 PARCIALMENTE VALIDADA', 'color: orange; font-size: 16px; font-weight: bold;');
    console.log('%cA m√©trica funciona, mas precisa de ajustes.', 'color: orange;');
  } else {
    console.log('%c‚ùå M√âTRICA 2 N√ÉO VALIDADA', 'color: red; font-size: 16px; font-weight: bold;');
    console.log('%cA m√©trica precisa de corre√ß√µes antes de ser considerada v√°lida.', 'color: red;');
  }

  // 9. Recomenda√ß√µes espec√≠ficas
  console.log('\nüí° RECOMENDA√á√ïES:');
  if (!formulaIsCorrect) {
    console.log('   ‚Ä¢ Verificar o c√°lculo da f√≥rmula no backend');
  }
  if (!isInRange) {
    console.log('   ‚Ä¢ Corrigir o valor da taxa (deve estar entre 0% e 100%)');
  }
  if (!hasValidData) {
    console.log('   ‚Ä¢ Verificar a consist√™ncia dos contadores DC e DT');
  }
  if (!interpretationIsCorrect) {
    console.log('   ‚Ä¢ Ajustar a interpreta√ß√£o para a taxa atual');
  }

  return {
    score,
    isValid: score >= 80,
    metrics: { DC, DT, x },
    details: {
      formulaIsCorrect,
      isInRange, 
      hasValidData,
      interpretationIsCorrect
    },
    rawData: metricsData
  };
};

// Fun√ß√£o para testar cen√°rios espec√≠ficos
const testSpecificScenarios = () => {
  console.log('\nüß™ TESTE DE CEN√ÅRIOS ESPEC√çFICOS:');
  
  const scenarios = [
    { DC: 100, DT: 100, expectedX: 100, description: 'Cen√°rio ideal - 100% criptografado' },
    { DC: 0, DT: 100, expectedX: 0, description: 'Cen√°rio cr√≠tico - 0% criptografado' },
    { DC: 75, DT: 100, expectedX: 75, description: 'Cen√°rio bom - 75% criptografado' },
    { DC: 45, DT: 100, expectedX: 45, description: 'Cen√°rio regular - 45% criptografado' }
  ];

  scenarios.forEach((scenario, index) => {
    const calculated = (scenario.DC / scenario.DT) * 100;
    const isCorrect = Math.abs(calculated - scenario.expectedX) < 0.01;
    
    console.log(`   ${isCorrect ? '‚úÖ' : '‚ùå'} ${scenario.description}: ${scenario.DC}/${scenario.DT} = ${calculated}%`);
  });
};

// Executar a valida√ß√£o principal
console.log('\nüöÄ INICIANDO VALIDA√á√ÉO DA M√âTRICA 2...');
validateSecurityMetric2().then(results => {
  console.log('\n===============================================');
  console.log('üí° COMANDOS DISPON√çVEIS:');
  console.log('   ‚Ä¢ validateSecurityMetric2() - Reexecutar valida√ß√£o');
  console.log('   ‚Ä¢ testSpecificScenarios() - Testar cen√°rios espec√≠ficos');
  console.log('   ‚Ä¢ results - Ver resultados detalhados');
});

// Tamb√©m expor as fun√ß√µes globalmente para uso posterior
window.validateSecurityMetric2 = validateSecurityMetric2;
window.testSpecificScenarios = testSpecificScenarios;