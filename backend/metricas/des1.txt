// VALIDA√á√ÉO DA M√âTRICA DE TAXA DE FALHAS DE RESPOSTA
console.log('üìä VALIDA√á√ÉO - M√©trica de Taxa de Falhas de Resposta');
console.log('F√≥rmula: x = RF √∑ RT √ó 100');
console.log('RF = Requisi√ß√µes com Falha');
console.log('RT = Total de Requisi√ß√µes');
console.log('===================================================');

// Fun√ß√£o principal de valida√ß√£o
const validateResponseFailureRate = () => {
  console.log('\nüìã CHECKLIST DE VALIDA√á√ÉO:');
  
  // 1. Coletar dados de requisi√ß√µes da aplica√ß√£o
  let requestData = null;
  try {
    // Tentar obter dados reais da aplica√ß√£o
    if (window.performance && window.performance.getEntriesByType) {
      const performanceEntries = window.performance.getEntriesByType('resource');
      const apiRequests = performanceEntries.filter(entry => 
        entry.name.includes('/api/') || entry.name.includes('localhost:3000')
      );
      
      const totalRequests = apiRequests.length;
      const failedRequests = apiRequests.filter(entry => {
        // Considerar como falha se status n√£o for 2xx ou se duration > 5000ms
        return (entry.responseStatus && entry.responseStatus >= 400) || 
               entry.duration > 5000;
      }).length;
      
      requestData = {
        failedRequests: failedRequests,
        totalRequests: totalRequests,
        failureRate: totalRequests > 0 ? (failedRequests / totalRequests) * 100 : 0
      };
      
      console.log('‚úÖ 1. Dados reais coletados do performance API');
    } else {
      console.log('‚ÑπÔ∏è 1. Performance API n√£o dispon√≠vel, usando dados de teste');
      requestData = {
        failedRequests: 12,    // RF
        totalRequests: 245,    // RT
        failureRate: 4.90      // x
      };
    }
  } catch (error) {
    console.log('‚ùå 1. Erro ao coletar dados:', error.message);
    console.log('   üí° Usando dados de teste...');
    requestData = {
      failedRequests: 12,    // RF
      totalRequests: 245,    // RT
      failureRate: 4.90      // x
    };
  }

  const RF = requestData.failedRequests;
  const RT = requestData.totalRequests;
  const x = requestData.failureRate;

  console.log('\nüìä DADOS COLETADOS:');
  console.log(`   RF (Requisi√ß√µes com Falha): ${RF}`);
  console.log(`   RT (Total de Requisi√ß√µes): ${RT}`);
  console.log(`   x (Taxa de Falhas): ${x.toFixed(2)}%`);

  // 2. Validar a f√≥rmula
  console.log('\nüßÆ VALIDA√á√ÉO DA F√ìRMULA:');
  const calculatedX = RT > 0 ? (RF / RT) * 100 : 0;
  const formulaIsCorrect = Math.abs(calculatedX - x) < 0.01;
  
  console.log(`   F√≥rmula: x = ${RF} √∑ ${RT} √ó 100`);
  console.log(`   Calculado: ${calculatedX.toFixed(2)}%`);
  console.log(`   Registrado: ${x.toFixed(2)}%`);
  console.log(`   ‚úÖ F√≥rmula correta: ${formulaIsCorrect ? 'SIM' : 'N√ÉO'}`);

  // 3. Validar range (0% a 100%)
  console.log('\nüìà VALIDA√á√ÉO DO RANGE:');
  const isInRange = x >= 0 && x <= 100;
  console.log(`   0 ‚â§ ${x.toFixed(2)}% ‚â§ 100: ${isInRange ? '‚úÖ DENTRO' : '‚ùå FORA'}`);

  // 4. Validar consist√™ncia dos dados
  console.log('\nüîç VALIDA√á√ÉO DE CONSIST√äNCIA:');
  const hasValidData = RF >= 0 && RT >= 0 && RF <= RT;
  console.log(`   RF ‚â• 0: ${RF >= 0}`);
  console.log(`   RT ‚â• 0: ${RT >= 0}`); 
  console.log(`   RF ‚â§ RT: ${RF <= RT}`);
  console.log(`   ‚úÖ Dados consistentes: ${hasValidData ? 'SIM' : 'N√ÉO'}`);

  // 5. Interpreta√ß√£o da m√©trica
  console.log('\nüìñ INTERPRETA√á√ÉO:');
  let interpretation = '';
  let status = '';
  
  if (x === 0) {
    interpretation = 'Excelente - Nenhuma falha detectada';
    status = 'üü¢ PERFEITO';
  } else if (x <= 5) {
    interpretation = 'Bom - Taxa de falhas muito baixa';
    status = 'üü¢ √ìTIMO';
  } else if (x <= 10) {
    interpretation = 'Regular - Taxa de falhas aceit√°vel';
    status = 'üü° RAZO√ÅVEL';
  } else if (x <= 20) {
    interpretation = 'Preocupante - Taxa de falhas alta';
    status = 'üü† ALERTA';
  } else {
    interpretation = 'Cr√≠tico - Taxa de falhas muito alta';
    status = 'üî¥ CR√çTICO';
  }
  
  console.log(`   ${status}: ${interpretation}`);
  console.log(`   Valores pr√≥ximos a 0% indicam maior confiabilidade`);

  // 6. Calcular pontua√ß√£o
  console.log('\nüéØ PONTUA√á√ÉO FINAL:');
  let score = 0;
  if (formulaIsCorrect) score += 40;
  if (isInRange) score += 30;
  if (hasValidData) score += 30;

  console.log(`   F√≥rmula correta: ${formulaIsCorrect ? '+40' : '+0'}`);
  console.log(`   Range v√°lido: ${isInRange ? '+30' : '+0'}`);
  console.log(`   Dados consistentes: ${hasValidData ? '+30' : '+0'}`);
  console.log(`   üìä PONTUA√á√ÉO TOTAL: ${score}/100`);

  // 7. Recomenda√ß√µes
  console.log('\nüí° RECOMENDA√á√ïES:');
  if (x > 10) {
    console.log('   üîß Implementar retry autom√°tico para requisi√ß√µes falhas');
    console.log('   üîß Melhorar tratamento de erros no frontend');
    console.log('   üîß Monitorar sa√∫de da API backend');
  } else if (x > 5) {
    console.log('   üîß Revisar logs de erro recentes');
    console.log('   üîß Verificar conectividade de rede');
  } else {
    console.log('   ‚úÖ Sistema est√°vel - manter monitoramento');
  }

  // 8. Resultado final
  console.log('\nüéä RESULTADO FINAL:');
  if (score >= 80) {
    console.log('%c‚úÖ M√âTRICA VALIDADA COM SUCESSO!', 'color: green; font-size: 16px; font-weight: bold;');
    console.log('%cA M√©trica de Taxa de Falhas de Resposta est√° funcionando corretamente.', 'color: green;');
  } else {
    console.log('%c‚ùå M√âTRICA N√ÉO VALIDADA', 'color: red; font-size: 16px; font-weight: bold;');
    console.log('%cA m√©trica precisa de ajustes antes de ser considerada v√°lida.', 'color: red;');
  }

  return {
    score,
    isValid: score >= 80,
    metrics: { RF, RT, x },
    interpretation: interpretation,
    status: status,
    details: {
      formulaIsCorrect,
      isInRange, 
      hasValidData
    }
  };
};

// Fun√ß√£o para simular diferentes cen√°rios de teste
const testFailureRateScenarios = () => {
  console.log('\nüé≠ TESTANDO CEN√ÅRIOS DIFERENTES:');
  
  const scenarios = [
    { RF: 0, RT: 100, desc: 'Cen√°rio Perfeito' },
    { RF: 5, RT: 100, desc: 'Cen√°rio Bom' },
    { RF: 15, RT: 100, desc: 'Cen√°rio Regular' },
    { RF: 25, RT: 100, desc: 'Cen√°rio Cr√≠tico' },
    { RF: 50, RT: 50, desc: 'Cen√°rio Extremo' }
  ];
  
  scenarios.forEach(scenario => {
    const x = (scenario.RF / scenario.RT) * 100;
    console.log(`   ${scenario.desc}: ${scenario.RF}/${scenario.RT} = ${x.toFixed(1)}%`);
  });
};

// Executar a valida√ß√£o
console.log('üöÄ EXECUTANDO VALIDA√á√ÉO...');
const results = validateResponseFailureRate();

// Executar testes de cen√°rios
testFailureRateScenarios();

console.log('\nüí° COMANDOS DISPON√çVEIS:');
console.log('   ‚Ä¢ validateResponseFailureRate() - Reexecutar valida√ß√£o');
console.log('   ‚Ä¢ testFailureRateScenarios() - Testar diferentes cen√°rios');
console.log('   ‚Ä¢ results - Ver resultados detalhados');

// Expor fun√ß√µes globalmente para reuso
window.validateResponseFailureRate = validateResponseFailureRate;
window.testFailureRateScenarios = testFailureRateScenarios;