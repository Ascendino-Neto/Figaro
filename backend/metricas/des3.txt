// VALIDA√á√ÉO DA M√âTRICA DE REQUISI√á√ïES RESPONDIDAS EM AT√â 5s
console.log('üéØ VALIDA√á√ÉO - Percentual de Requisi√ß√µes Respondidas em at√© 5s');
console.log('F√≥rmula: x = RR √∑ RT √ó 100');
console.log('RR = Requisi√ß√µes respondidas em ‚â§ 5s');
console.log('RT = Total de requisi√ß√µes');
console.log('============================================================');

// Fun√ß√£o principal de valida√ß√£o
const validateFiveSecondResponseRate = () => {
  console.log('\nüìã CHECKLIST DE VALIDA√á√ÉO:');
  
  // 1. Coletar dados de performance da aplica√ß√£o
  let responseData = null;
  try {
    // Tentar obter dados reais da Performance API
    if (window.performance && window.performance.getEntriesByType) {
      const performanceEntries = window.performance.getEntriesByType('resource');
      const apiRequests = performanceEntries.filter(entry => 
        entry.name.includes('/api/') || 
        entry.name.includes('localhost:3000') ||
        entry.initiatorType === 'xmlhttprequest' ||
        entry.initiatorType === 'fetch'
      );
      
      const totalRequests = apiRequests.length;
      
      if (totalRequests > 0) {
        const fastRequests = apiRequests.filter(entry => entry.duration <= 5000).length;
        const successRate = totalRequests > 0 ? (fastRequests / totalRequests) * 100 : 0;
        
        responseData = {
          fastRequests: fastRequests,
          totalRequests: totalRequests,
          successRate: successRate,
          slowRequests: totalRequests - fastRequests,
          individualRequests: apiRequests.map(entry => ({
            url: entry.name,
            time: entry.duration,
            status: entry.duration <= 5000 ? '‚úÖ DENTRO' : '‚ùå FORA',
            withinLimit: entry.duration <= 5000
          })).slice(0, 15) // Mostrar apenas os primeiros 15
        };
        
        console.log('‚úÖ 1. Dados reais coletados da Performance API');
        console.log(`   üìû ${totalRequests} requisi√ß√µes API analisadas`);
      } else {
        console.log('‚ÑπÔ∏è 1. Nenhuma requisi√ß√£o API encontrada, usando dados de teste');
        responseData = getTestData();
      }
    } else {
      console.log('‚ÑπÔ∏è 1. Performance API n√£o dispon√≠vel, usando dados de teste');
      responseData = getTestData();
    }
  } catch (error) {
    console.log('‚ùå 1. Erro ao coletar dados:', error.message);
    console.log('   üí° Usando dados de teste...');
    responseData = getTestData();
  }

  const RR = responseData.fastRequests;
  const RT = responseData.totalRequests;
  const x = responseData.successRate;

  console.log('\nüìä DADOS COLETADOS:');
  console.log(`   RR (Requisi√ß√µes r√°pidas ‚â§5s): ${RR}`);
  console.log(`   RT (Total de requisi√ß√µes): ${RT}`);
  console.log(`   x (Percentual): ${x.toFixed(2)}%`);

  // 2. Validar a f√≥rmula
  console.log('\nüßÆ VALIDA√á√ÉO DA F√ìRMULA:');
  const calculatedX = RT > 0 ? (RR / RT) * 100 : 0;
  const formulaIsCorrect = Math.abs(calculatedX - x) < 0.01;
  
  console.log(`   F√≥rmula: x = ${RR} √∑ ${RT} √ó 100`);
  console.log(`   Calculado: ${calculatedX.toFixed(2)}%`);
  console.log(`   Registrado: ${x.toFixed(2)}%`);
  console.log(`   ‚úÖ F√≥rmula correta: ${formulaIsCorrect ? 'SIM' : 'N√ÉO'}`);

  // 3. Validar range (0% a 100%)
  console.log('\nüìà VALIDA√á√ÉO DO RANGE:');
  const isInRange = x >= 0 && x <= 100;
  console.log(`   0 ‚â§ ${x.toFixed(2)}% ‚â§ 100: ${isInRange ? '‚úÖ DENTRO' : '‚ùå FORA'}`);

  // 4. Validar consist√™ncia dos dados
  console.log('\nüîç VALIDA√á√ÉO DE CONSIST√äNCIA:');
  const hasValidData = RR >= 0 && RT >= 0 && RR <= RT;
  console.log(`   RR ‚â• 0: ${RR >= 0}`);
  console.log(`   RT ‚â• 0: ${RT >= 0}`); 
  console.log(`   RR ‚â§ RT: ${RR <= RT}`);
  console.log(`   ‚úÖ Dados consistentes: ${hasValidData ? 'SIM' : 'N√ÉO'}`);

  // 5. Interpreta√ß√£o da m√©trica
  console.log('\nüìñ INTERPRETA√á√ÉO:');
  let interpretation = '';
  let status = '';
  let color = '';
  let meetsRequirement = x >= 95;
  
  if (x >= 98) {
    interpretation = 'Excelente - Performance consistente';
    status = 'üü¢ EXCELENTE';
    color = 'green';
  } else if (x >= 95) {
    interpretation = 'Bom - Atende ao requisito';
    status = 'üü¢ BOM';
    color = 'green';
  } else if (x >= 90) {
    interpretation = 'Regular - Pr√≥ximo do requisito';
    status = 'üü° REGULAR';
    color = 'orange';
  } else if (x >= 80) {
    interpretation = 'Preocupante - Abaixo do esperado';
    status = 'üü† PREOCUPANTE';
    color = 'darkorange';
  } else {
    interpretation = 'Cr√≠tico - Necessita otimiza√ß√£o urgente';
    status = 'üî¥ CR√çTICO';
    color = 'red';
  }
  
  console.log(`   %c${status}: ${interpretation}`, `color: ${color}; font-weight: bold;`);
  console.log(`   ‚úÖ Requisito atendido (x ‚â• 95%): ${meetsRequirement ? 'SIM' : 'N√ÉO'}`);
  console.log(`   üìä Meta: ${x.toFixed(2)}% / 95% (${Math.max(0, 95 - x).toFixed(2)}% abaixo)`);

  // 6. An√°lise detalhada das requisi√ß√µes
  if (responseData.individualRequests && responseData.individualRequests.length > 0) {
    console.log('\nüìä AN√ÅLISE DETALHADA:');
    
    const fastCount = responseData.individualRequests.filter(req => req.withinLimit).length;
    const slowCount = responseData.individualRequests.filter(req => !req.withinLimit).length;
    
    console.log(`   ‚úÖ Requisi√ß√µes dentro do limite (‚â§5s): ${fastCount}`);
    console.log(`   ‚ùå Requisi√ß√µes fora do limite (>5s): ${slowCount}`);
    console.log(`   üìà Taxa de sucesso na amostra: ${((fastCount / responseData.individualRequests.length) * 100).toFixed(1)}%`);
    
    // Mostrar requisi√ß√µes lentas (se houver)
    const slowRequests = responseData.individualRequests.filter(req => !req.withinLimit);
    if (slowRequests.length > 0) {
      console.log(`   üêå Requisi√ß√µes lentas detectadas:`);
      slowRequests.forEach((req, index) => {
        const url = req.url.length > 40 ? req.url.substring(0, 37) + '...' : req.url;
        console.log(`      ${index + 1}. ${url}`);
        console.log(`         ‚è∞ ${req.time.toFixed(0)}ms (${(req.time / 1000).toFixed(1)}s)`);
      });
    }
    
    // Distribui√ß√£o de tempos
    console.log(`   üìã Distribui√ß√£o de tempos:`);
    const timeRanges = [
      { range: '‚â§1s', max: 1000, count: 0 },
      { range: '1-3s', max: 3000, count: 0 },
      { range: '3-5s', max: 5000, count: 0 },
      { range: '>5s', max: Infinity, count: 0 }
    ];
    
    responseData.individualRequests.forEach(req => {
      const range = timeRanges.find(r => req.time <= r.max);
      if (range) range.count++;
    });
    
    timeRanges.forEach(range => {
      const percent = (range.count / responseData.individualRequests.length * 100).toFixed(1);
      console.log(`      ${range.range}: ${range.count} (${percent}%)`);
    });
  }

  // 7. Calcular pontua√ß√£o
  console.log('\nüéØ PONTUA√á√ÉO FINAL:');
  let score = 0;
  if (formulaIsCorrect) score += 40;
  if (isInRange) score += 30;
  if (hasValidData) score += 30;

  // B√¥nus por atender ao requisito
  const bonus = meetsRequirement ? 10 : 0;
  score = Math.min(100, score + bonus);

  console.log(`   F√≥rmula correta: ${formulaIsCorrect ? '+40' : '+0'}`);
  console.log(`   Range v√°lido: ${isInRange ? '+30' : '+0'}`);
  console.log(`   Dados consistentes: ${hasValidData ? '+30' : '+0'}`);
  console.log(`   Requisito atendido: ${meetsRequirement ? '+10' : '+0'}`);
  console.log(`   üìä PONTUA√á√ÉO TOTAL: ${score}/100`);

  // 8. Recomenda√ß√µes baseadas no resultado
  console.log('\nüí° RECOMENDA√á√ïES:');
  if (x < 95) {
    const gap = (95 - x).toFixed(1);
    console.log(`   üö® Necess√°rio melhorar ${gap}% para atingir a meta de 95%`);
    
    if (x < 80) {
      console.log('   üö® Identificar e otimizar endpoints cr√≠ticos');
      console.log('   üö® Implementar cache agressivo');
      console.log('   üö® Revisar infraestrutura do servidor');
    } else if (x < 90) {
      console.log('   üîß Otimizar queries de banco de dados');
      console.log('   üîß Implementar pagina√ß√£o em listas grandes');
      console.log('   üîß Reduzir tamanho de payloads');
    } else {
      console.log('   üîß Ajustes finos em endpoints espec√≠ficos');
      console.log('   üîß Monitorar performance continuamente');
    }
  } else {
    console.log('   ‚úÖ Meta de 95% atingida com sucesso!');
    console.log('   ‚úÖ Manter monitoramento cont√≠nuo');
    console.log('   ‚úÖ Considerar meta mais ambiciosa (98%+)');
  }

  // 9. Resultado final
  console.log('\nüéä RESULTADO FINAL:');
  if (score >= 80) {
    console.log('%c‚úÖ M√âTRICA VALIDADA COM SUCESSO!', 'color: green; font-size: 16px; font-weight: bold;');
    console.log('%cA M√©trica de Percentual em 5s est√° funcionando corretamente.', 'color: green;');
  } else {
    console.log('%c‚ùå M√âTRICA N√ÉO VALIDADA', 'color: red; font-size: 16px; font-weight: bold;');
    console.log('%cA m√©trica precisa de ajustes antes de ser considerada v√°lida.', 'color: red;');
  }

  return {
    score,
    isValid: score >= 80,
    meetsRequirement: meetsRequirement,
    metrics: { 
      fastRequests: RR, 
      totalRequests: RT, 
      successRate: x,
      slowRequests: responseData.slowRequests
    },
    interpretation: interpretation,
    status: status,
    requirement: {
      target: 95,
      current: x,
      gap: Math.max(0, 95 - x)
    },
    details: {
      formulaIsCorrect,
      isInRange, 
      hasValidData
    }
  };
};

// Fun√ß√µes auxiliares
function getTestData() {
  // Dados de teste realistas para desenvolvimento
  const testRequests = [
    { time: 1200, withinLimit: true },
    { time: 800, withinLimit: true },
    { time: 4500, withinLimit: true },
    { time: 2300, withinLimit: true },
    { time: 6200, withinLimit: false },
    { time: 3400, withinLimit: true },
    { time: 1500, withinLimit: true },
    { time: 2800, withinLimit: true },
    { time: 5100, withinLimit: false },
    { time: 1900, withinLimit: true }
  ];
  
  const fastRequests = testRequests.filter(req => req.withinLimit).length;
  const totalRequests = testRequests.length;
  const successRate = (fastRequests / totalRequests) * 100;
  
  return {
    fastRequests: fastRequests,
    totalRequests: totalRequests,
    successRate: successRate,
    slowRequests: totalRequests - fastRequests,
    individualRequests: testRequests.map((req, index) => ({
      url: `/api/endpoint-${index + 1}`,
      time: req.time,
      status: req.withinLimit ? '‚úÖ DENTRO' : '‚ùå FORA',
      withinLimit: req.withinLimit
    }))
  };
}

// Fun√ß√£o para simular diferentes cen√°rios de performance
const testResponseRateScenarios = () => {
  console.log('\nüé≠ CEN√ÅRIOS DE TAXA DE RESPOSTA:');
  
  const scenarios = [
    { fast: 100, total: 100, desc: 'Perfeito - 100% em 5s' },
    { fast: 98, total: 100, desc: 'Excelente - 98% em 5s' },
    { fast: 95, total: 100, desc: 'Meta - 95% em 5s' },
    { fast: 90, total: 100, desc: 'Regular - 90% em 5s' },
    { fast: 80, total: 100, desc: 'Preocupante - 80% em 5s' },
    { fast: 60, total: 100, desc: 'Cr√≠tico - 60% em 5s' }
  ];
  
  scenarios.forEach(scenario => {
    const rate = (scenario.fast / scenario.total) * 100;
    let status = '';
    
    if (rate >= 98) status = 'üü¢';
    else if (rate >= 95) status = 'üü¢';
    else if (rate >= 90) status = 'üü°';
    else if (rate >= 80) status = 'üü†';
    else status = 'üî¥';
    
    const meetsReq = rate >= 95 ? '‚úÖ' : '‚ùå';
    console.log(`   ${status} ${meetsReq} ${scenario.desc}: ${rate.toFixed(0)}%`);
  });
};

// Fun√ß√£o para analisar endpoints espec√≠ficos
const analyzeEndpoints = () => {
  if (!window.performance) {
    console.log('‚ùå Performance API n√£o dispon√≠vel');
    return;
  }
  
  const entries = window.performance.getEntriesByType('resource');
  const apiEntries = entries.filter(entry => 
    entry.name.includes('/api/') || entry.name.includes('localhost:3000/api/')
  );
  
  if (apiEntries.length === 0) {
    console.log('üîç Nenhum endpoint API encontrado para an√°lise');
    return;
  }
  
  // Agrupar por endpoint
  const endpointMap = {};
  apiEntries.forEach(entry => {
    const url = new URL(entry.name);
    const endpoint = url.pathname;
    
    if (!endpointMap[endpoint]) {
      endpointMap[endpoint] = {
        count: 0,
        fast: 0,
        totalTime: 0,
        times: []
      };
    }
    
    endpointMap[endpoint].count++;
    endpointMap[endpoint].totalTime += entry.duration;
    endpointMap[endpoint].times.push(entry.duration);
    
    if (entry.duration <= 5000) {
      endpointMap[endpoint].fast++;
    }
  });
  
  console.log('\nüîç AN√ÅLISE POR ENDPOINT:');
  Object.entries(endpointMap).forEach(([endpoint, data]) => {
    const successRate = (data.fast / data.count) * 100;
    const avgTime = data.totalTime / data.count;
    const status = successRate >= 95 ? '‚úÖ' : successRate >= 90 ? '‚ö†Ô∏è' : '‚ùå';
    
    console.log(`   ${status} ${endpoint}`);
    console.log(`      üìä ${data.fast}/${data.count} (${successRate.toFixed(1)}%) em 5s`);
    console.log(`      ‚è∞ M√©dia: ${avgTime.toFixed(0)}ms`);
  });
};

// Executar a valida√ß√£o
console.log('üöÄ EXECUTANDO VALIDA√á√ÉO DO PERCENTUAL EM 5s...');
const results = validateFiveSecondResponseRate();

// Executar testes de cen√°rios
testResponseRateScenarios();

// Analisar endpoints espec√≠ficos
analyzeEndpoints();

console.log('\nüí° COMANDOS DISPON√çVEIS:');
console.log('   ‚Ä¢ validateFiveSecondResponseRate() - Reexecutar valida√ß√£o');
console.log('   ‚Ä¢ testResponseRateScenarios() - Testar diferentes cen√°rios');
console.log('   ‚Ä¢ analyzeEndpoints() - Analisar performance por endpoint');
console.log('   ‚Ä¢ results - Ver resultados detalhados');

// Expor fun√ß√µes globalmente para reuso
window.validateFiveSecondResponseRate = validateFiveSecondResponseRate;
window.testResponseRateScenarios = testResponseRateScenarios;
window.analyzeEndpoints = analyzeEndpoints;