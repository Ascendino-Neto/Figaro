// VALIDA√á√ÉO DA M√âTRICA DE TEMPO M√âDIO DE RESPOSTA
console.log('‚ö° VALIDA√á√ÉO - M√©trica de Tempo M√©dio de Resposta');
console.log('F√≥rmula: x = (soma dos tempos de resposta) √∑ N');
console.log('N = n√∫mero de requisi√ß√µes');
console.log('================================================');

// Fun√ß√£o principal de valida√ß√£o
const validateAverageResponseTime = () => {
  console.log('\nüìã CHECKLIST DE VALIDA√á√ÉO:');
  
  // 1. Coletar dados de performance da aplica√ß√£o
  let responseTimeData = null;
  try {
    // Tentar obter dados reais da Performance API
    if (window.performance && window.performance.getEntriesByType) {
      const performanceEntries = window.performance.getEntriesByType('resource');
      const apiRequests = performanceEntries.filter(entry => 
        entry.name.includes('/api/') || 
        entry.name.includes('localhost:3000') ||
        entry.initiatorType === 'xmlhttprequest' ||
        entry.initiatorType === 'fetch'
      );
      
      const totalRequests = apiRequests.length;
      
      if (totalRequests > 0) {
        const totalResponseTime = apiRequests.reduce((sum, entry) => sum + entry.duration, 0);
        const averageResponseTime = totalResponseTime / totalRequests;
        
        responseTimeData = {
          totalResponseTime: totalResponseTime,
          numberOfRequests: totalRequests,
          averageResponseTime: averageResponseTime,
          individualTimes: apiRequests.map(entry => ({
            url: entry.name,
            time: entry.duration
          })).slice(0, 10) // Mostrar apenas os primeiros 10
        };
        
        console.log('‚úÖ 1. Dados reais coletados da Performance API');
        console.log(`   üìû ${totalRequests} requisi√ß√µes API encontradas`);
      } else {
        console.log('‚ÑπÔ∏è 1. Nenhuma requisi√ß√£o API encontrada, usando dados de teste');
        responseTimeData = getTestData();
      }
    } else {
      console.log('‚ÑπÔ∏è 1. Performance API n√£o dispon√≠vel, usando dados de teste');
      responseTimeData = getTestData();
    }
  } catch (error) {
    console.log('‚ùå 1. Erro ao coletar dados:', error.message);
    console.log('   üí° Usando dados de teste...');
    responseTimeData = getTestData();
  }

  const totalTime = responseTimeData.totalResponseTime;
  const N = responseTimeData.numberOfRequests;
  const x = responseTimeData.averageResponseTime;

  console.log('\nüìä DADOS COLETADOS:');
  console.log(`   Soma dos tempos: ${totalTime.toFixed(2)}ms`);
  console.log(`   N (N√∫mero de requisi√ß√µes): ${N}`);
  console.log(`   x (Tempo m√©dio): ${x.toFixed(2)}ms`);

  // 2. Validar a f√≥rmula
  console.log('\nüßÆ VALIDA√á√ÉO DA F√ìRMULA:');
  const calculatedX = N > 0 ? totalTime / N : 0;
  const formulaIsCorrect = Math.abs(calculatedX - x) < 0.01;
  
  console.log(`   F√≥rmula: x = ${totalTime.toFixed(2)} √∑ ${N}`);
  console.log(`   Calculado: ${calculatedX.toFixed(2)}ms`);
  console.log(`   Registrado: ${x.toFixed(2)}ms`);
  console.log(`   ‚úÖ F√≥rmula correta: ${formulaIsCorrect ? 'SIM' : 'N√ÉO'}`);

  // 3. Validar range (0ms a limite pr√°tico)
  console.log('\nüìà VALIDA√á√ÉO DO RANGE:');
  const isInRange = x >= 0 && x <= 30000; // 30 segundos como limite m√°ximo razo√°vel
  console.log(`   0 ‚â§ ${x.toFixed(2)}ms ‚â§ 30000ms: ${isInRange ? '‚úÖ DENTRO' : '‚ùå FORA'}`);

  // 4. Validar consist√™ncia dos dados
  console.log('\nüîç VALIDA√á√ÉO DE CONSIST√äNCIA:');
  const hasValidData = totalTime >= 0 && N >= 0 && (N === 0 || totalTime >= 0);
  console.log(`   Soma tempos ‚â• 0: ${totalTime >= 0}`);
  console.log(`   N ‚â• 0: ${N >= 0}`); 
  console.log(`   Dados coerentes: ${hasValidData ? 'SIM' : 'N√ÉO'}`);

  // 5. Interpreta√ß√£o da m√©trica
  console.log('\nüìñ INTERPRETA√á√ÉO:');
  let interpretation = '';
  let status = '';
  let color = '';
  
  if (x <= 500) { // 0.5 segundos
    interpretation = 'Excelente - Sistema muito r√°pido';
    status = 'üü¢ EXCELENTE';
    color = 'green';
  } else if (x <= 1000) { // 1 segundo
    interpretation = 'Bom - Sistema r√°pido';
    status = 'üü¢ BOM';
    color = 'green';
  } else if (x <= 3000) { // 3 segundos
    interpretation = 'Regular - Velocidade aceit√°vel';
    status = 'üü° REGULAR';
    color = 'orange';
  } else if (x <= 5000) { // 5 segundos
    interpretation = 'Lento - Necessita otimiza√ß√£o';
    status = 'üü† LENTO';
    color = 'darkorange';
  } else {
    interpretation = 'Muito lento - Problemas cr√≠ticos';
    status = 'üî¥ CR√çTICO';
    color = 'red';
  }
  
  console.log(`   %c${status}: ${interpretation}`, `color: ${color}; font-weight: bold;`);
  console.log(`   Meta ideal: x ‚â§ 500ms (0.5 segundos)`);
  console.log(`   Limite aceit√°vel: x ‚â§ 5000ms (5 segundos)`);

  // 6. An√°lise detalhada dos tempos
  if (responseTimeData.individualTimes && responseTimeData.individualTimes.length > 0) {
    console.log('\nüìä AN√ÅLISE DETALHADA:');
    const times = responseTimeData.individualTimes.map(t => t.time);
    const maxTime = Math.max(...times);
    const minTime = Math.min(...times);
    const medianTime = calculateMedian(times);
    
    console.log(`   ‚è±Ô∏è  Tempo mais r√°pido: ${minTime.toFixed(2)}ms`);
    console.log(`   ‚è±Ô∏è  Tempo mais lento: ${maxTime.toFixed(2)}ms`);
    console.log(`   üìä Mediana: ${medianTime.toFixed(2)}ms`);
    console.log(`   üìà Desvio: ¬±${calculateStandardDeviation(times).toFixed(2)}ms`);
    
    // Mostrar algumas requisi√ß√µes espec√≠ficas
    console.log(`   üîç Amostra de requisi√ß√µes:`);
    responseTimeData.individualTimes.slice(0, 3).forEach((req, index) => {
      const url = req.url.length > 50 ? req.url.substring(0, 47) + '...' : req.url;
      console.log(`      ${index + 1}. ${url}`);
      console.log(`         ‚è∞ ${req.time.toFixed(2)}ms`);
    });
  }

  // 7. Calcular pontua√ß√£o
  console.log('\nüéØ PONTUA√á√ÉO FINAL:');
  let score = 0;
  if (formulaIsCorrect) score += 40;
  if (isInRange) score += 30;
  if (hasValidData) score += 30;

  console.log(`   F√≥rmula correta: ${formulaIsCorrect ? '+40' : '+0'}`);
  console.log(`   Range v√°lido: ${isInRange ? '+30' : '+0'}`);
  console.log(`   Dados consistentes: ${hasValidData ? '+30' : '+0'}`);
  console.log(`   üìä PONTUA√á√ÉO TOTAL: ${score}/100`);

  // 8. Recomenda√ß√µes baseadas no resultado
  console.log('\nüí° RECOMENDA√á√ïES:');
  if (x > 3000) {
    console.log('   üö® Otimizar endpoints mais lentos');
    console.log('   üö® Implementar cache de requisi√ß√µes');
    console.log('   üö® Revisar queries de banco de dados');
  } else if (x > 1000) {
    console.log('   üîß Monitorar performance continuamente');
    console.log('   üîß Considerar lazy loading');
    console.log('   üîß Otimizar tamanho de payloads');
  } else if (x > 500) {
    console.log('   ‚úÖ Sistema com boa performance');
    console.log('   ‚úÖ Manter boas pr√°ticas atuais');
  } else {
    console.log('   üéâ Performance excelente!');
    console.log('   üéâ Manter padr√µes atuais');
  }

  // 9. Resultado final
  console.log('\nüéä RESULTADO FINAL:');
  if (score >= 80) {
    console.log('%c‚úÖ M√âTRICA VALIDADA COM SUCESSO!', 'color: green; font-size: 16px; font-weight: bold;');
    console.log('%cA M√©trica de Tempo M√©dio de Resposta est√° funcionando corretamente.', 'color: green;');
  } else {
    console.log('%c‚ùå M√âTRICA N√ÉO VALIDADA', 'color: red; font-size: 16px; font-weight: bold;');
    console.log('%cA m√©trica precisa de ajustes antes de ser considerada v√°lida.', 'color: red;');
  }

  return {
    score,
    isValid: score >= 80,
    metrics: { totalResponseTime: totalTime, numberOfRequests: N, averageResponseTime: x },
    interpretation: interpretation,
    status: status,
    performance: responseTimeData.individualTimes,
    details: {
      formulaIsCorrect,
      isInRange, 
      hasValidData
    }
  };
};

// Fun√ß√µes auxiliares
function getTestData() {
  // Dados de teste realistas para desenvolvimento
  const testTimes = [120, 450, 780, 230, 890, 340, 670, 150, 920, 280];
  const totalTime = testTimes.reduce((sum, time) => sum + time, 0);
  
  return {
    totalResponseTime: totalTime,
    numberOfRequests: testTimes.length,
    averageResponseTime: totalTime / testTimes.length,
    individualTimes: testTimes.map((time, index) => ({
      url: `/api/test-endpoint-${index + 1}`,
      time: time
    }))
  };
}

function calculateMedian(numbers) {
  const sorted = [...numbers].sort((a, b) => a - b);
  const middle = Math.floor(sorted.length / 2);
  
  if (sorted.length % 2 === 0) {
    return (sorted[middle - 1] + sorted[middle]) / 2;
  }
  
  return sorted[middle];
}

function calculateStandardDeviation(numbers) {
  const avg = numbers.reduce((sum, num) => sum + num, 0) / numbers.length;
  const squareDiffs = numbers.map(num => Math.pow(num - avg, 2));
  const avgSquareDiff = squareDiffs.reduce((sum, diff) => sum + diff, 0) / numbers.length;
  return Math.sqrt(avgSquareDiff);
}

// Fun√ß√£o para simular diferentes cen√°rios de performance
const testPerformanceScenarios = () => {
  console.log('\nüé≠ CEN√ÅRIOS DE PERFORMANCE:');
  
  const scenarios = [
    { totalTime: 2500, requests: 10, desc: '√ìtimo - 250ms m√©dio' },
    { totalTime: 8000, requests: 10, desc: 'Bom - 800ms m√©dio' },
    { totalTime: 25000, requests: 10, desc: 'Regular - 2.5s m√©dio' },
    { totalTime: 45000, requests: 10, desc: 'Limite - 4.5s m√©dio' },
    { totalTime: 80000, requests: 10, desc: 'Cr√≠tico - 8s m√©dio' }
  ];
  
  scenarios.forEach(scenario => {
    const avg = scenario.totalTime / scenario.requests;
    let status = '';
    
    if (avg <= 500) status = 'üü¢';
    else if (avg <= 1000) status = 'üü°';
    else if (avg <= 5000) status = 'üü†';
    else status = 'üî¥';
    
    console.log(`   ${status} ${scenario.desc}: ${avg.toFixed(0)}ms`);
  });
};

// Fun√ß√£o para monitorar uma requisi√ß√£o espec√≠fica
const monitorSpecificRequest = (urlPattern) => {
  if (!window.performance) {
    console.log('‚ùå Performance API n√£o dispon√≠vel');
    return;
  }
  
  const entries = window.performance.getEntriesByType('resource');
  const matchingEntries = entries.filter(entry => 
    entry.name.includes(urlPattern)
  );
  
  if (matchingEntries.length === 0) {
    console.log(`üîç Nenhuma requisi√ß√£o encontrada para: ${urlPattern}`);
    return;
  }
  
  console.log(`\nüîç MONITORANDO: ${urlPattern}`);
  matchingEntries.forEach(entry => {
    console.log(`   üìç ${entry.name}`);
    console.log(`   ‚è∞ Tempo: ${entry.duration.toFixed(2)}ms`);
    console.log(`   üìè Tamanho: ${entry.transferSize || 'N/A'} bytes`);
  });
};

// Executar a valida√ß√£o
console.log('üöÄ EXECUTANDO VALIDA√á√ÉO DO TEMPO M√âDIO DE RESPOSTA...');
const results = validateAverageResponseTime();

// Executar testes de cen√°rios
testPerformanceScenarios();

console.log('\nüí° COMANDOS DISPON√çVEIS:');
console.log('   ‚Ä¢ validateAverageResponseTime() - Reexecutar valida√ß√£o');
console.log('   ‚Ä¢ testPerformanceScenarios() - Testar diferentes cen√°rios');
console.log('   ‚Ä¢ monitorSpecificRequest("api/") - Monitorar requisi√ß√µes espec√≠ficas');
console.log('   ‚Ä¢ results - Ver resultados detalhados');

// Expor fun√ß√µes globalmente para reuso
window.validateAverageResponseTime = validateAverageResponseTime;
window.testPerformanceScenarios = testPerformanceScenarios;
window.monitorSpecificRequest = monitorSpecificRequest;